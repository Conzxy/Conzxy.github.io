<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Lab1 Booting a PC | Conzxy's blog</title><meta name="keywords" content="os,process"><meta name="author" content="Conzxy,1967933844@qq.com"><meta name="copyright" content="Conzxy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Lab1: Booting a PC">
<meta property="og:type" content="article">
<meta property="og:title" content="Lab1 Booting a PC">
<meta property="og:url" content="https://conzxy.github.io/2022/02/09/jos/lab1/index.html">
<meta property="og:site_name" content="Conzxy&#39;s blog">
<meta property="og:description" content="Lab1: Booting a PC">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://conzxy.github.io/img/shinku1.png">
<meta property="article:published_time" content="2022-02-09T07:14:50.942Z">
<meta property="article:modified_time" content="2022-04-25T13:51:23.291Z">
<meta property="article:author" content="Conzxy">
<meta property="article:tag" content="os">
<meta property="article:tag" content="process">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://conzxy.github.io/img/shinku1.png"><link rel="shortcut icon" href="https://s2.loli.net/2022/08/11/GzwcjJWagFYDrqA.png"><link rel="canonical" href="https://conzxy.github.io/2022/02/09/jos/lab1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"N9Z0PM0HJZ","apiKey":"6d906e58a3775dbc633767eedd5e917a","indexName":"conzxy_blog","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Lab1 Booting a PC',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-25 21:51:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/user.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2022/08/11/FL2oCbPv5MNiDgK.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">93</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">57</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">47</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw 首页"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw 归档"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw 标签"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw 分类"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/shinku1.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Conzxy's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw 首页"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw 归档"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw 标签"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw 分类"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Lab1 Booting a PC</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-09T07:14:50.942Z" title="发表于 2022-02-09 15:14:50">2022-02-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-25T13:51:23.291Z" title="更新于 2022-04-25 21:51:23">2022-04-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/os/">os</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>17分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Lab1 Booting a PC"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2022/02/09/jos/lab1/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Lab1-Booting-a-PC"><a href="#Lab1-Booting-a-PC" class="headerlink" title="Lab1: Booting a PC"></a>Lab1: Booting a PC</h1><span id="more"></span>
<h1 id="Part1-PC-Bootstrap"><a href="#Part1-PC-Bootstrap" class="headerlink" title="Part1 PC Bootstrap"></a>Part1 PC Bootstrap</h1><h2 id="Getting-Started-with-x86-assembly"><a href="#Getting-Started-with-x86-assembly" class="headerlink" title="Getting Started with x86 assembly"></a>Getting Started with x86 assembly</h2><p>整个实验使用的汇编语言都是x86，因此需要了解x86的语法和一些技巧。需要注意的是使用语法格式是<code>AT&amp;T</code>风格而不是<code>Intel</code>风格，具体来说，一个显著的区别在于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov src, dst # This is AT&amp;T style</span><br><span class="line">mov dst, src # This is Intel style</span><br></pre></td></tr></table></figure>
<h2 id="Simulating-the-x86"><a href="#Simulating-the-x86" class="headerlink" title="Simulating the x86"></a>Simulating the x86</h2><p>实现环境不采用实机而是通过<code>QEMU</code>模拟器，更为方便。<code>QEMU</code>可以提供远程调试模板，这个在之后的跟踪内核启动指令有用。</p>
<p>通过make生成内核映像（<code>obj/kern/kernel.img</code>)，它包含两部分：<code>boot loader</code>(<code>obj/boot/boot</code>)和<code>kernel</code>(<code>obj/kernel</code>)，然后通过<code>QEMU</code>加载该映像启动内核。</p>
<p>实现提供了一个Makefile文件，里面有准备好的命令，敲入<code>make qemu</code>就能启动PC了：<br><img src="https://s2.loli.net/2022/04/24/CLP2idUqBxokXpT.png" alt="image.png"><br>退出方式：<strong>Ctrl+a x</strong><br>现在内核提供了一个显示器（Monitor），可以接受键盘输入，开始可以输入的有效命令只有两个：<br><img src="https://s2.loli.net/2022/04/24/3DR2FJPlMSOvEuh.png" alt="image.png"></p>
<p>调试该内核，则使用如下指令<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// terminal window 1</span><br><span class="line">make qemu-gdb</span><br><span class="line"></span><br><span class="line">// terminal window 2</span><br><span class="line">make gdb</span><br></pre></td></tr></table></figure></p>
<h2 id="The-PC’s-Physical-Address-Space"><a href="#The-PC’s-Physical-Address-Space" class="headerlink" title="The PC’s Physical Address Space"></a>The PC’s Physical Address Space</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</span><br><span class="line">|      32-bit      |</span><br><span class="line">|  memory mapped   |</span><br><span class="line">|     devices      |</span><br><span class="line">|                  |</span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line"></span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line">|                  |</span><br><span class="line">|      Unused      |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- depends on amount of RAM</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">| Extended Memory  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB)</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB)</span><br><span class="line">|  16-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure>
<h2 id="The-ROM-BIOS"><a href="#The-ROM-BIOS" class="headerlink" title="The ROM BIOS"></a>The ROM BIOS</h2><p>使用<code>gdb</code>调试内核。<br><img src="https://s2.loli.net/2022/04/17/B4HtVeyXlEvUrJh.png" alt="image-20220209152023351.png"></p>
<p>开始执行指令的物理地址为<code>0x000ffff0</code>，对照内存空间不难发现这是在64KB BIOS的顶部</p>
<p>第一个指令是<code>ljmp</code>，跳转到的地址为<code>cs: 0xf000, ip: 0xe05d</code>，即<code>0xfe05d</code>，至于为什么要跳转，文档给出的理由是只有16字节啥都干不了，所以要跳到BIOS的前面去（<code>0xf0000~0xfffff</code>）。</p>
<p>BIOS安置中断描述符表（<code>interrupt descriptor table</code>）和初始化各种设备（比如VGA display）。</p>
<p>在初始化PCI总线和所有BIOS知晓的重要设备后，它搜索可启动（bootable）设备，比如软盘（floppy），硬件驱动（hard drive），CD-ROM。最终，找到了可启动硬盘，BIOS从中读取boot loader，并将控制转交给它。</p>
<p>如果硬盘是可启动的，那么第一个扇区是<code>boot sector</code>，<code>boot loader</code>的代码就在那里。BIOS会将<code>boot sector</code>加载到物理地址<code>0x7c00~0x7dff</code>,接着跳转到<code>0000:7c00</code>，转交控制给<code>boot loader</code>。</p>
<p>随着PC发展，后面采用的不是软件或硬盘，而是<code>CD-ROM</code>，它更复杂同时也更强大，使用的是<strong>2048</strong>字节的扇区大小，可以加载更大的启动印象（boot image）到内存中。</p>
<p>JOS采用的是传统做法，即加载512字节大小的扇区。</p>
<blockquote>
<p>Exercise 2<br>使用si命令跟踪ROM BIOS的指令，尝试猜测它在干什么。不需要搞懂所有细节，仅大概了解BIOS在启动时所做的工作是什么。</p>
</blockquote>
<p>笼统来说，BIOS的工作是：<br>初始化硬件设备等，找到第一个可启动硬盘并将其第一个扇区加载到0x7c00~0x7dff，然后转交控制给boot loader（jmp 0000:7c00)</p>
<h1 id="Part2-Boot-Loader"><a href="#Part2-Boot-Loader" class="headerlink" title="Part2: Boot Loader"></a>Part2: Boot Loader</h1><p><code>boot loader</code>的工作有以下几点：</p>
<ul>
<li>将cpu模式由<code>16bit实模式</code>切换到<code>32bit保护模式</code>（<strong>boot/boot.S</strong>)</li>
<li>从硬盘加载内核到内存中并转交控制权给内核（<strong>boot/main.c</strong>)</li>
</ul>
<p>为了看懂这两个文件，我们要了解<code>实模式（real mode）</code>和<code>保护模式（protected mode）</code>。</p>
<h2 id="实模式和保护模式"><a href="#实模式和保护模式" class="headerlink" title="实模式和保护模式"></a>实模式和保护模式</h2><p>在实模式下，只有16bit模式，同时内存被限制为1MB，但是16位的寄存器不能表示所有物理地址，因此intel用两个16位值解决这个问题，第一个值为<code>选择器（selector）</code>，存储在<code>段寄存器（segment register）</code>中，第二个值是<code>偏移（offset）</code>。因此物理地址可以表示为：</p>
<script type="math/tex; mode=display">
physical \ address = 16 \times selector + offset</script><p>但是16bit的实模式问题很多，</p>
<ul>
<li>单个选择器最多只能引用64KB的内存，假如程序不只64KB，那么就需要跨段，对于DS也是同理。</li>
<li>每个物理地址的表示方式并不唯一，比如<code>047c:0048</code>和<code>047d:0038</code>表示的物理地址是相同的，如果要区分那么必须两部分都比较。</li>
</ul>
<p><strong>Intel 80286</strong>引入了16bit的保护模式，在实模式，选择器是物理地址的段落，但在保护模式，它是<code>描述符表（descriptor table）</code>的索引，它们并不是物理内存的固定位置，每个段在描述符表中有自己的项，这个项有一些元数据：访问权限，是否在内存中，内存的位置（如果在）。</p>
<p>也正是从保护模式开始，使用了<code>虚拟内存</code>的技术。仅维持当前程序使用的代码和数据，其他的放在硬盘上，待需要时再用，段也就往返于内存和硬盘间了。所有这一切当然对用户是透明的，方便了用户编写程序。</p>
<p>很多机制都贴近现在的虚拟内存了，但是效率不高：段的粒度不一，有大有小，每次换入换出都是以段作为单位。根据局部性原则，采用固定的块（即page）是更好的，而16bit保护模式仍是段分。</p>
<p>同时也没有突破段的限制（64KB）。</p>
<p><strong>Intel 80386</strong>引入了32bit的保护模式，</p>
<ul>
<li>偏移扩展为32位。这样段最大为4GB。</li>
<li>段被划分为更小的页（4KB小页，4GB大页）</li>
</ul>
<p>虚拟内存的主要部分是在<code>lab2</code>，这里主要是涉及了实模式到保护模式的切换，所以稍微提一下。</p>
<p>JOS设置qemu的cpu为<code>i386</code>（<code>make qemu</code>可以知道），因此一个这个cpu的编程文档对于解读该实验的一些细节很有用：<a target="_blank" rel="noopener" href="http://www.logix.cz/michal/doc/i386/">Intel 80386 Programmer’s Reference Manual </a></p>
<p>其中第5章讲述就是<code>段转化（segment translation）</code>，其中有些东西这里有用。</p>
<h2 id="段转化"><a href="#段转化" class="headerlink" title="段转化"></a>段转化</h2><h3 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h3><p><code>段描述符（segment descriptor）</code>一般不由程序员提供（但是这个实验还是得由你提供）。它的字段如下：</p>
<ul>
<li><strong>Base</strong>：定义段的位置。有3个部分，cpu将其组合在一起是32位值</li>
<li><strong>Limit</strong>：定义段的大小。有两个部分，cpu组合起来是20位值。这里cpu解释它有两个粒度：1B和4KB。</li>
<li><strong>Granularity bit（粒度位）</strong>：置位表示4KB，未置位则表示1B。</li>
<li><strong>Type（类型）</strong>：</li>
<li><strong>Descriptor privilege level（DPL，特权级别）</strong>：保护机制</li>
<li><strong>Segment-Present Bit（存在位）：为0表示描述符无效（即此时它已经被换出内存了）</strong>。和page的类似，如果访问的时候不在的话触发异常。OS如果不同，可以标记该位为<code>AVALIABLE</code>。</li>
<li><strong>Accessed bit（访问位）</strong>：当该段被访问后，置位。用途好像主要是用于基于段实现的虚拟内存OS监控段使用频率（定期测试和清空）</li>
</ul>
<p><img src="https://s2.loli.net/2022/04/17/1K7MA38vqi5Dboz.png" alt="image-20220209214830386.png"></p>
<p><img src="https://s2.loli.net/2022/04/17/sDUNf59Qp67iyem.png" alt="image-20220210145054196.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// Application segment type bits</span><br><span class="line">#define STA_X		0x8	    // Executable segment</span><br><span class="line">#define STA_E		0x4	    // Expand down (non-executable segments)</span><br><span class="line">#define STA_C		0x4	    // Conforming code segment (executable only)</span><br><span class="line">#define STA_W		0x2	    // Writeable (non-executable segments)</span><br><span class="line">#define STA_R		0x2	    // Readable (executable segments)</span><br><span class="line">#define STA_A		0x1	    // Accessed</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Macros to build GDT entries in assembly.</span><br><span class="line"> */</span><br><span class="line">#define SEG_NULL						\</span><br><span class="line">	.word 0, 0;						\</span><br><span class="line">	.byte 0, 0, 0, 0</span><br><span class="line">#define SEG(type,base,lim)					\</span><br><span class="line">	.word (((lim) &gt;&gt; 12) &amp; 0xffff), ((base) &amp; 0xffff);	\</span><br><span class="line">	.byte (((base) &gt;&gt; 16) &amp; 0xff), (0x90 | (type)),		\</span><br><span class="line">		(0xC0 | (((lim) &gt;&gt; 28) &amp; 0xf)), (((base) &gt;&gt; 24) &amp; 0xff)</span><br><span class="line"></span><br><span class="line">#else	// not __ASSEMBLER__</span><br></pre></td></tr></table></figure>
<p>在<code>&lt;inc/mmu.h&gt;</code>中有一段就是段描述符的宏，SEG_NULL是给第一个元素用的，因为不被使用。</p>
<p>第二个SEG是应用段，采用的格式是上面第一张图片，其中由于一开始A必然为0，而type最低位也是0，所以不需要考虑A的情况，dpl也不需要考虑。</p>
<p><code>0xC0</code>是一个比较迷惑的点，最高位表示粒度为4KB，还有一位是X，这个在386的手册中并未解释，我翻了IA-32第三卷发现了下面的段描述符格式：</p>
<p><img src="https://s2.loli.net/2022/04/17/kZ1CiAcDjyvwMmp.png" alt="image-20220210150546397.png"></p>
<p>由此看来该位是决定该段是16bit还是32bit，在该实验肯定是32bit，所以置为1。</p>
<p>通过xv6的<code>&lt;asm.h&gt;</code>的注释也可以知道这个描述是没有问题的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The 0xC0 means the limit is in 4096-byte units</span></span><br><span class="line"><span class="comment">// and (for executable segments) 32-bit mode.</span></span><br></pre></td></tr></table></figure>
<p>（至于386手册为什么没写，可能当时该位不起任何作用？）</p>
<h3 id="段描述符表"><a href="#段描述符表" class="headerlink" title="段描述符表"></a>段描述符表</h3><p>有两种描述符表：</p>
<ul>
<li><strong>Global Descriptor Table（GDT）</strong></li>
<li><strong>Local Descriptor Table（LDT）</strong></li>
</ul>
<p>这个在接下来和<code>lab3</code>都有用，所以有必要讲下。</p>
<p>描述符表示为数组，其中的元素就是8B的描述符（最多8192个元素）。第一个元素并不被cpu使用。</p>
<p>cpu通过<code>GDTR</code>和<code>LDTR</code>寄存器定位GDT和LDT。这两个寄存器存储两个数据：</p>
<ul>
<li>base address： 在地址空间的位置</li>
<li>segment limits：大小</li>
</ul>
<p><code>LGDT</code>，<code>SGDT</code>是对GDT的load/store指令，<a target="_blank" rel="noopener" href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">Intel 64 and IA-32 Intel Architecture Software Developer’s Manuals</a>第二卷A有<code>LGDT</code>的说明</p>
<p><img src="https://s2.loli.net/2022/04/17/WqsT6kubBgRAX7I.png" alt="image-20220209222513934.png"></p>
<p>（64的是给64位模式使用的，我们用不到，略）</p>
<p>16bit是limit， 而32bit的是base address。</p>
<p>LGDT的操作数是一个地址，这个地址包含这两个字段：低2字节是大小，高4字节是base address。</p>
<p>在实模式（即本实验中）的用法算是一种惯用法（idiom）</p>
<p>需要注意一点，就是<code>limit</code>实际是$8N-1$，</p>
<h2 id="boot-S"><a href="#boot-S" class="headerlink" title="boot.S"></a>boot.S</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;inc/mmu.h&gt;</span><br><span class="line"></span><br><span class="line"># Start the CPU: switch to 32-bit protected mode, jump into C.</span><br><span class="line"># The BIOS loads this code from the first sector of the hard disk into</span><br><span class="line"># memory at physical address 0x7c00 and starts executing in real mode</span><br><span class="line"># with %cs=0 %ip=7c00.</span><br><span class="line"></span><br><span class="line">.set PROT_MODE_CSEG, 0x8         # kernel code segment selector</span><br><span class="line">.set PROT_MODE_DSEG, 0x10        # kernel data segment selector</span><br><span class="line">.set CR0_PE_ON,      0x1         # protected mode enable flag</span><br><span class="line"></span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">  .code16                     # Assemble for 16-bit mode</span><br><span class="line">  cli                         # Disable interrupts</span><br><span class="line">  cld                         # String operations increment</span><br><span class="line"></span><br><span class="line">  # Set up the important data segment registers (DS, ES, SS).</span><br><span class="line">  xorw    %ax,%ax             # Segment number zero</span><br><span class="line">  movw    %ax,%ds             # -&gt; Data Segment</span><br><span class="line">  movw    %ax,%es             # -&gt; Extra Segment</span><br><span class="line">  movw    %ax,%ss             # -&gt; Stack Segment</span><br><span class="line"></span><br><span class="line">  # Enable A20:</span><br><span class="line">  #   For backwards compatibility with the earliest PCs, physical</span><br><span class="line">  #   address line 20 is tied low, so that addresses higher than</span><br><span class="line">  #   1MB wrap around to zero by default.  This code undoes this.</span><br><span class="line">seta20.1:</span><br><span class="line">  inb     $0x64,%al               # Wait for not busy</span><br><span class="line">  testb   $0x2,%al</span><br><span class="line">  jnz     seta20.1</span><br><span class="line"></span><br><span class="line">  movb    $0xd1,%al               # 0xd1 -&gt; port 0x64</span><br><span class="line">  outb    %al,$0x64</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">  inb     $0x64,%al               # Wait for not busy</span><br><span class="line">  testb   $0x2,%al</span><br><span class="line">  jnz     seta20.2</span><br><span class="line"></span><br><span class="line">  movb    $0xdf,%al               # 0xdf -&gt; port 0x60</span><br><span class="line">  outb    %al,$0x60</span><br><span class="line"></span><br><span class="line">  # Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line">  # and segment translation that makes virtual addresses </span><br><span class="line">  # identical to their physical addresses, so that the </span><br><span class="line">  # effective memory map does not change during the switch.</span><br><span class="line">  lgdt    gdtdesc</span><br><span class="line">  movl    %cr0, %eax</span><br><span class="line">  orl     $CR0_PE_ON, %eax</span><br><span class="line">  movl    %eax, %cr0</span><br><span class="line">  </span><br><span class="line">  # Jump to next instruction, but in 32-bit code segment.</span><br><span class="line">  # Switches processor into 32-bit mode.</span><br><span class="line">  ljmp    $PROT_MODE_CSEG, $protcseg</span><br><span class="line"></span><br><span class="line">  .code32                     # Assemble for 32-bit mode</span><br><span class="line">protcseg:</span><br><span class="line">  # Set up the protected-mode data segment registers</span><br><span class="line">  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector</span><br><span class="line">  movw    %ax, %ds                # -&gt; DS: Data Segment</span><br><span class="line">  movw    %ax, %es                # -&gt; ES: Extra Segment</span><br><span class="line">  movw    %ax, %fs                # -&gt; FS</span><br><span class="line">  movw    %ax, %gs                # -&gt; GS</span><br><span class="line">  movw    %ax, %ss                # -&gt; SS: Stack Segment</span><br><span class="line">  </span><br><span class="line">  # Set up the stack pointer and call into C.</span><br><span class="line">  movl    $start, %esp</span><br><span class="line">  call bootmain</span><br><span class="line"></span><br><span class="line">  # If bootmain returns (it shouldn&#x27;t), loop.</span><br><span class="line">spin:</span><br><span class="line">  jmp spin</span><br><span class="line"></span><br><span class="line"># Bootstrap GDT</span><br><span class="line">.p2align 2                                # force 4 byte alignment</span><br><span class="line">gdt:</span><br><span class="line">  SEG_NULL				# null seg</span><br><span class="line">  SEG(STA_X|STA_R, 0x0, 0xffffffff)	# code seg</span><br><span class="line">  SEG(STA_W, 0x0, 0xffffffff)	        # data seg</span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">  .word   0x17                            # sizeof(gdt) - 1</span><br><span class="line">  .long   gdt                             # address gdt</span><br></pre></td></tr></table></figure>
<p>代码注释其实写的很详细了，这里讲一下大概的流程：</p>
<p>首先关掉中断，因为原本是用于BIOS初始化工作用的，现在没有必要开启，在内核准备完毕后再打开。</p>
<p>由于各个段寄存器在BIOS工作做完之后，不一定为空，所以需要全部置零。</p>
<p>然后是A20使能，这个步骤是为了向后兼容，不搞懂它也没有关系，毕竟是历史遗留。主要是为了强制忽略超过1MB的地址第21位，这样就不会出现与早期PC的兼容性问题。有兴趣可以看下：</p>
<p><img src="https://s2.loli.net/2022/04/17/6TxjByinwvL5apA.png" alt="image-20220210153228488.png"></p>
<p>之后的一步，就是需要加载GDT，通过它，即使切换到了保护模式，也能保持虚拟地址（或逻辑地址）与物理地址等同，这样内存映射的逻辑不会被打乱。</p>
<p>然后通过<code>CR0（控制寄存器）</code>,将<code>PE</code>(Protection Enable)置位，便切换到了保护模式，但还未进入32位模式。</p>
<p>通过<code>ljmp</code>跳转用到的代码段寄存器，切换到了32位模式（因为<code>0xC0</code>），</p>
<p>然后将保护模式下的段寄存器们全部设置为现在的数据段，保持一致。</p>
<p>这里有个小问题就是栈应该设置在哪里？内核会加载到<code>0x100000</code>，而boot loader是<code>0x7c00-0x7e00</code>，由于栈是向下增长，因此可以设为<code>0x7c00</code>，即<code>start</code>标签处（31KB对于boot loader应该够用了）</p>
<p>然后调用bootmain读取内核。</p>
<p>至此，boot.S的工作完成。</p>
<h2 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/x86.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inc/elf.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"> * This a dirt simple boot loader, whose sole job is to boot</span></span><br><span class="line"><span class="comment"> * an ELF kernel image from the first IDE hard disk.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DISK LAYOUT</span></span><br><span class="line"><span class="comment"> *  * This program(boot.S and main.c) is the bootloader.  It should</span></span><br><span class="line"><span class="comment"> *    be stored in the first sector of the disk.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * The 2nd sector onward holds the kernel image.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * The kernel image must be in ELF format.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * BOOT UP STEPS</span></span><br><span class="line"><span class="comment"> *  * when the CPU boots it loads the BIOS into memory and executes it</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * the BIOS intializes devices, sets of the interrupt routines, and</span></span><br><span class="line"><span class="comment"> *    reads the first sector of the boot device(e.g., hard-drive)</span></span><br><span class="line"><span class="comment"> *    into memory and jumps to it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * Assuming this boot loader is stored in the first sector of the</span></span><br><span class="line"><span class="comment"> *    hard-drive, this code takes over...</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * control starts in boot.S -- which sets up protected mode,</span></span><br><span class="line"><span class="comment"> *    and a stack so C code then run, then calls bootmain()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * bootmain() in this file takes over, reads in the kernel and jumps to it.</span></span><br><span class="line"><span class="comment"> **********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECTSIZE	512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELFHDR		((struct Elf *) 0x10000) <span class="comment">// scratch space</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">readsect</span><span class="params">(<span class="type">void</span>*, <span class="type">uint32_t</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">readseg</span><span class="params">(<span class="type">uint32_t</span>, <span class="type">uint32_t</span>, <span class="type">uint32_t</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bootmain</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// read 1st page off disk</span></span><br><span class="line">	readseg((<span class="type">uint32_t</span>) ELFHDR, SECTSIZE*<span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// is this a valid ELF?</span></span><br><span class="line">	<span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC)</span><br><span class="line">		<span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// load each program segment (ignores ph flags)</span></span><br><span class="line">	ph = (<span class="keyword">struct</span> Proghdr *) ((<span class="type">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">	eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">	<span class="keyword">for</span> (; ph &lt; eph; ph++)</span><br><span class="line">		<span class="comment">// p_pa is the load address of this segment (as well</span></span><br><span class="line">		<span class="comment">// as the physical address)</span></span><br><span class="line">		readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// call the entry point from the ELF header</span></span><br><span class="line">	<span class="comment">// note: does not return!</span></span><br><span class="line">	((<span class="type">void</span> (*)(<span class="type">void</span>)) (ELFHDR-&gt;e_entry))();</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">	outw(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</span><br><span class="line">	outw(<span class="number">0x8A00</span>, <span class="number">0x8E00</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">		<span class="comment">/* do nothing */</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read &#x27;count&#x27; bytes at &#x27;offset&#x27; from kernel into physical address &#x27;pa&#x27;.</span></span><br><span class="line"><span class="comment">// Might copy more than asked</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">readseg</span><span class="params">(<span class="type">uint32_t</span> pa, <span class="type">uint32_t</span> count, <span class="type">uint32_t</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> end_pa;</span><br><span class="line"></span><br><span class="line">	end_pa = pa + count;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// round down to sector boundary</span></span><br><span class="line">	pa &amp;= ~(SECTSIZE - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// translate from bytes to sectors, and kernel starts at sector 1</span></span><br><span class="line">	offset = (offset / SECTSIZE) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If this is too slow, we could read lots of sectors at a time.</span></span><br><span class="line">	<span class="comment">// We&#x27;d write more to memory than asked, but it doesn&#x27;t matter --</span></span><br><span class="line">	<span class="comment">// we load in increasing order.</span></span><br><span class="line">	<span class="keyword">while</span> (pa &lt; end_pa) &#123;</span><br><span class="line">		<span class="comment">// Since we haven&#x27;t enabled paging yet and we&#x27;re using</span></span><br><span class="line">		<span class="comment">// an identity segment mapping (see boot.S), we can</span></span><br><span class="line">		<span class="comment">// use physical addresses directly.  This won&#x27;t be the</span></span><br><span class="line">		<span class="comment">// case once JOS enables the MMU.</span></span><br><span class="line">		readsect((<span class="type">uint8_t</span>*) pa, offset);</span><br><span class="line">		pa += SECTSIZE;</span><br><span class="line">		offset++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">waitdisk</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// wait for disk reaady</span></span><br><span class="line">	<span class="keyword">while</span> ((inb(<span class="number">0x1F7</span>) &amp; <span class="number">0xC0</span>) != <span class="number">0x40</span>)</span><br><span class="line">		<span class="comment">/* do nothing */</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">readsect</span><span class="params">(<span class="type">void</span> *dst, <span class="type">uint32_t</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// wait for disk to be ready</span></span><br><span class="line">	waitdisk();</span><br><span class="line"></span><br><span class="line">	outb(<span class="number">0x1F2</span>, <span class="number">1</span>);		<span class="comment">// count = 1</span></span><br><span class="line">	outb(<span class="number">0x1F3</span>, offset);</span><br><span class="line">	outb(<span class="number">0x1F4</span>, offset &gt;&gt; <span class="number">8</span>);</span><br><span class="line">	outb(<span class="number">0x1F5</span>, offset &gt;&gt; <span class="number">16</span>);</span><br><span class="line">	outb(<span class="number">0x1F6</span>, (offset &gt;&gt; <span class="number">24</span>) | <span class="number">0xE0</span>);</span><br><span class="line">	outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);	<span class="comment">// cmd 0x20 - read sectors</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// wait for disk to be ready</span></span><br><span class="line">	waitdisk();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// read a sector</span></span><br><span class="line">	insl(<span class="number">0x1F0</span>, dst, SECTSIZE/<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意文件开头的注释，硬盘的布局如下：<br><img src="https://s2.loli.net/2022/04/24/t6WdqvB1UgKuRGI.png" alt="image.png"><br>因此能够它会假设内核映像在硬盘上的位置在第二个扇区及之后。</p>
<p>至此，加载内核映像完成。</p>
<p>Boot的流程：</p>
<ul>
<li>加载ROM中的BIOS到内存中并执行它</li>
<li>BIOS初始化硬件设备，读取第一个扇区（启动扇区）到指定的位置并转交控制给boot loader</li>
<li>boot loader启动保护模式和设置栈（mov $start, %esp）以至于C代码能够运行，然后调用<code>bootmain()</code></li>
<li><code>bootmain()</code>读取内核并转交控制给内核</li>
</ul>
<h2 id="Debug相关"><a href="#Debug相关" class="headerlink" title="Debug相关"></a>Debug相关</h2><ul>
<li><code>obj/boot/boot.asm</code>：boot loader</li>
<li><code>obj/kern/kernel.asm</code>： JOS内核</li>
</ul>
<p>两个是已经反汇编好的汇编文件，其中装载地址都已经填好了，对于debug来说是很有用的</p>
<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>lab1的文档提了一下问题：</p>
<blockquote>
<p>At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?</p>
<ul>
<li><code>.code32</code>后都是32位模式</li>
<li><code>ljmp $PROT_MODE_CSEG, $prot_cseg</code></li>
</ul>
<p>What is the <em>last</em> instruction of the boot loader executed, and what is the <em>first</em> instruction of the kernel it just loaded?</p>
</blockquote>
<ul>
<li>最后的语句应该是<code>boot/main.c</code>中bootmain函数最后一句，就是调用内核入口函数，不过这里指的是最后的指令，从<code>obj/boot/boot.asm</code>可以看出应为：<code>call *0x10018</code>，这个地址有点特别，这个和ELF有关。</li>
<li>内核执行的第一条指令为<code>movw $0x1234, 0x472</code>（<code>obj/kern/kernel.asm</code>）</li>
</ul>
<blockquote>
<p><em>Where</em> is the first instruction of the kernel?</p>
</blockquote>
<p>应该为<code>kern/entry.S</code></p>
<blockquote>
<p>How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?</p>
</blockquote>
<p>8个扇区，从<code>boot/main.c</code>中bootmain函数第二条语句可知</p>
<h1 id="Part3-Load-Kernel"><a href="#Part3-Load-Kernel" class="headerlink" title="Part3: Load Kernel"></a>Part3: Load Kernel</h1><p><code>obj/kern/kernel</code>就是我们的内核映像了，也就是我们常说的可执行文件，文件格式是ELF（Executable and linkable format， 和linux用的一样）。</p>
<p>对这个不熟悉的可以看csapp或《程序员的自我修养》，当然，在课程的reference page也提供了资料：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/readings/elf.pdf">elf.pdf (mit.edu)</a></p>
<p>然后为了解读ELF文件，要用到<code>objdump</code>工具，看名字就知道是用来解读目标文件（object file）的，使用方式可以通过<code>objdump --help</code>查看。</p>
<p>我们要查看ELF的section，用如下指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -h obj/kern/kernel</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/04/17/SuB9CYo8trimU5g.png" alt="image-20220210235632851.png"></p>
<p>其中，需要注意的是<code>.text</code>的<code>VMA（link address）</code>和<code>LMA（load address）</code>是不一致的，</p>
<p>链接地址是节（section，有的译作“段”，避免混淆，采用“节”）期望执行的内存地址，而装载（或载入）地址是节应该被加载到的内存地址，也就是说最终内核的代码是装载到低地址，而期望执行的是高地址，这算是一种惯用法吧，我只知道linux好像也是这样弄的。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://conzxy.github.io">Conzxy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://conzxy.github.io/2022/02/09/jos/lab1/">https://conzxy.github.io/2022/02/09/jos/lab1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://conzxy.github.io" target="_blank">Conzxy's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/os/">os</a><a class="post-meta__tags" href="/tags/process/">process</a></div><div class="post_share"><div class="social-share" data-image="/img/shinku1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/07/Cpp/Concurrent/rwlatch/"><img class="prev-cover" src="/img/shinku1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Think of RWLatch</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/28/stl/forward_list/"><img class="next-cover" src="/img/shinku1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">My ForwardList Implemetation</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/11/07/jos/lab3/" title="Lab3 User environments"><img class="cover" src="/img/shinku1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-07</div><div class="title">Lab3 User environments</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2022/08/11/FL2oCbPv5MNiDgK.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Conzxy</div><div class="author-info__description">blog</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">93</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">57</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">47</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Conzxy"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Conzxy" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/1967933844@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Cpper，最近对分布式系统、编译器设计感兴趣</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Lab1-Booting-a-PC"><span class="toc-number">1.</span> <span class="toc-text">Lab1: Booting a PC</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Part1-PC-Bootstrap"><span class="toc-number">2.</span> <span class="toc-text">Part1 PC Bootstrap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Getting-Started-with-x86-assembly"><span class="toc-number">2.1.</span> <span class="toc-text">Getting Started with x86 assembly</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Simulating-the-x86"><span class="toc-number">2.2.</span> <span class="toc-text">Simulating the x86</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-PC%E2%80%99s-Physical-Address-Space"><span class="toc-number">2.3.</span> <span class="toc-text">The PC’s Physical Address Space</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-ROM-BIOS"><span class="toc-number">2.4.</span> <span class="toc-text">The ROM BIOS</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Part2-Boot-Loader"><span class="toc-number">3.</span> <span class="toc-text">Part2: Boot Loader</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">实模式和保护模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%E8%BD%AC%E5%8C%96"><span class="toc-number">3.2.</span> <span class="toc-text">段转化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">3.2.1.</span> <span class="toc-text">段描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8"><span class="toc-number">3.2.2.</span> <span class="toc-text">段描述符表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#boot-S"><span class="toc-number">3.3.</span> <span class="toc-text">boot.S</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#main-c"><span class="toc-number">3.4.</span> <span class="toc-text">main.c</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Debug%E7%9B%B8%E5%85%B3"><span class="toc-number">3.5.</span> <span class="toc-text">Debug相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Question"><span class="toc-number">3.6.</span> <span class="toc-text">Question</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Part3-Load-Kernel"><span class="toc-number">4.</span> <span class="toc-text">Part3: Load Kernel</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/09/02/distributed-system/protobuf_rpc_callback/" title="实现自己的Closure以使rpc的回调兼容所有可调用对象"><img src="https://s2.loli.net/2022/09/02/wQVD6FU5zjCyurE.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="实现自己的Closure以使rpc的回调兼容所有可调用对象"/></a><div class="content"><a class="title" href="/2022/09/02/distributed-system/protobuf_rpc_callback/" title="实现自己的Closure以使rpc的回调兼容所有可调用对象">实现自己的Closure以使rpc的回调兼容所有可调用对象</a><time datetime="2022-09-02T05:39:49.536Z" title="发表于 2022-09-02 13:39:49">2022-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/02/distributed-system/service_discovery/" title="对Service Discovery with router tier的思考"><img src="https://s2.loli.net/2022/09/02/IymaQWxA14lEPgO.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="对Service Discovery with router tier的思考"/></a><div class="content"><a class="title" href="/2022/09/02/distributed-system/service_discovery/" title="对Service Discovery with router tier的思考">对Service Discovery with router tier的思考</a><time datetime="2022-09-02T02:47:26.780Z" title="发表于 2022-09-02 10:47:26">2022-09-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/24/cos333/regex/" title="COS333 assignment1 -- glob"><img src="https://s2.loli.net/2022/08/24/JugsZfl9qcHMSFt.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="COS333 assignment1 -- glob"/></a><div class="content"><a class="title" href="/2022/08/24/cos333/regex/" title="COS333 assignment1 -- glob">COS333 assignment1 -- glob</a><time datetime="2022-08-24T05:02:10.935Z" title="发表于 2022-08-24 13:02:10">2022-08-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/23/cos333/base64/" title="base64 encoder &amp; decoder"><img src="https://s2.loli.net/2022/08/23/qlHRyp7inYC4jbt.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="base64 encoder &amp; decoder"/></a><div class="content"><a class="title" href="/2022/08/23/cos333/base64/" title="base64 encoder &amp; decoder">base64 encoder &amp; decoder</a><time datetime="2022-08-23T01:32:17.930Z" title="发表于 2022-08-23 09:32:17">2022-08-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/19/hexo/transparent_bg/" title="Hexo butterfly 4.3.1 背景透明度设置"><img src="https://s2.loli.net/2022/08/19/5AvhBfa3WFJjHen.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hexo butterfly 4.3.1 背景透明度设置"/></a><div class="content"><a class="title" href="/2022/08/19/hexo/transparent_bg/" title="Hexo butterfly 4.3.1 背景透明度设置">Hexo butterfly 4.3.1 背景透明度设置</a><time datetime="2022-08-18T16:31:31.164Z" title="发表于 2022-08-19 00:31:31">2022-08-19</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2022/08/18/XNnMbxd95EmwReV.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Conzxy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎来到Conzxy's blog，希望内容对你有所启发!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '777f04a5b126f26c2e07',
      clientSecret: '8f8dd09899f1d1d8f688e50ab6119b788982da7d',
      repo: 'Conzxy.github.io',
      owner: 'Conzxy',
      admin: ['Conzxy'],
      id: 'ac8563a93641aab8dabf31b728ae6b09',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>